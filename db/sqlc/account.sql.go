// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: account.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (
    username,
    email,
    profile_picture_url,
    bio,
    last_login,
    is_admin,
    is_active,
    last_deactivated_at,
    n_followers,
    n_following,
    n_tweets
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets
`

type CreateAccountParams struct {
	Username          string             `json:"username"`
	Email             string             `json:"email"`
	ProfilePictureUrl pgtype.Text        `json:"profile_picture_url"`
	Bio               pgtype.Text        `json:"bio"`
	LastLogin         pgtype.Timestamptz `json:"last_login"`
	IsAdmin           bool               `json:"is_admin"`
	IsActive          bool               `json:"is_active"`
	LastDeactivatedAt pgtype.Timestamptz `json:"last_deactivated_at"`
	NFollowers        pgtype.Int4        `json:"n_followers"`
	NFollowing        pgtype.Int4        `json:"n_following"`
	NTweets           pgtype.Int4        `json:"n_tweets"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.Username,
		arg.Email,
		arg.ProfilePictureUrl,
		arg.Bio,
		arg.LastLogin,
		arg.IsAdmin,
		arg.IsActive,
		arg.LastDeactivatedAt,
		arg.NFollowers,
		arg.NFollowing,
		arg.NTweets,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}

const deleteAccountByEmail = `-- name: DeleteAccountByEmail :exec
DELETE FROM accounts WHERE email = $1
`

func (q *Queries) DeleteAccountByEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteAccountByEmail, email)
	return err
}

const deleteAccountByID = `-- name: DeleteAccountByID :exec
DELETE FROM accounts WHERE id = $1
`

func (q *Queries) DeleteAccountByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAccountByID, id)
	return err
}

const deleteAccountByUsername = `-- name: DeleteAccountByUsername :exec
DELETE FROM accounts WHERE username = $1
`

func (q *Queries) DeleteAccountByUsername(ctx context.Context, username string) error {
	_, err := q.db.Exec(ctx, deleteAccountByUsername, username)
	return err
}

const getAccountByEmail = `-- name: GetAccountByEmail :one
SELECT id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets FROM accounts WHERE email = $1
`

func (q *Queries) GetAccountByEmail(ctx context.Context, email string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByEmail, email)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets FROM accounts WHERE id = $1
`

func (q *Queries) GetAccountByID(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}

const getAccountByUsername = `-- name: GetAccountByUsername :one
SELECT id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets FROM accounts WHERE username = $1
`

func (q *Queries) GetAccountByUsername(ctx context.Context, username string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByUsername, username)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}

const getAccountByUsernameOrEmail = `-- name: GetAccountByUsernameOrEmail :one
SELECT id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets FROM accounts WHERE username = $1 OR email = $2
`

type GetAccountByUsernameOrEmailParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) GetAccountByUsernameOrEmail(ctx context.Context, arg GetAccountByUsernameOrEmailParams) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByUsernameOrEmail, arg.Username, arg.Email)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets FROM accounts ORDER BY id LIMIT $1 OFFSET $2
`

type ListAccountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.ProfilePictureUrl,
			&i.Bio,
			&i.LastLogin,
			&i.CreatedAt,
			&i.IsAdmin,
			&i.IsActive,
			&i.LastDeactivatedAt,
			&i.NFollowers,
			&i.NFollowing,
			&i.NTweets,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountByEmail = `-- name: UpdateAccountByEmail :one
UPDATE accounts SET
    username = $2,
    profile_picture_url = $3,
    bio = $4,
    last_login = $5,
    is_admin = $6,
    is_active = $7,
    last_deactivated_at = $8,
    n_followers = $9,
    n_following = $10,
    n_tweets = $11
WHERE email = $1 
RETURNING id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets
`

type UpdateAccountByEmailParams struct {
	Email             string             `json:"email"`
	Username          string             `json:"username"`
	ProfilePictureUrl pgtype.Text        `json:"profile_picture_url"`
	Bio               pgtype.Text        `json:"bio"`
	LastLogin         pgtype.Timestamptz `json:"last_login"`
	IsAdmin           bool               `json:"is_admin"`
	IsActive          bool               `json:"is_active"`
	LastDeactivatedAt pgtype.Timestamptz `json:"last_deactivated_at"`
	NFollowers        pgtype.Int4        `json:"n_followers"`
	NFollowing        pgtype.Int4        `json:"n_following"`
	NTweets           pgtype.Int4        `json:"n_tweets"`
}

func (q *Queries) UpdateAccountByEmail(ctx context.Context, arg UpdateAccountByEmailParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountByEmail,
		arg.Email,
		arg.Username,
		arg.ProfilePictureUrl,
		arg.Bio,
		arg.LastLogin,
		arg.IsAdmin,
		arg.IsActive,
		arg.LastDeactivatedAt,
		arg.NFollowers,
		arg.NFollowing,
		arg.NTweets,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}

const updateAccountByID = `-- name: UpdateAccountByID :one
UPDATE accounts SET
    username = $2,
    email = $3,
    profile_picture_url = $4,
    bio = $5,
    last_login = $6,
    is_admin = $7,
    is_active = $8,
    last_deactivated_at = $9,
    n_followers = $10,
    n_following = $11,
    n_tweets = $12
WHERE id = $1
RETURNING id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets
`

type UpdateAccountByIDParams struct {
	ID                int64              `json:"id"`
	Username          string             `json:"username"`
	Email             string             `json:"email"`
	ProfilePictureUrl pgtype.Text        `json:"profile_picture_url"`
	Bio               pgtype.Text        `json:"bio"`
	LastLogin         pgtype.Timestamptz `json:"last_login"`
	IsAdmin           bool               `json:"is_admin"`
	IsActive          bool               `json:"is_active"`
	LastDeactivatedAt pgtype.Timestamptz `json:"last_deactivated_at"`
	NFollowers        pgtype.Int4        `json:"n_followers"`
	NFollowing        pgtype.Int4        `json:"n_following"`
	NTweets           pgtype.Int4        `json:"n_tweets"`
}

func (q *Queries) UpdateAccountByID(ctx context.Context, arg UpdateAccountByIDParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountByID,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.ProfilePictureUrl,
		arg.Bio,
		arg.LastLogin,
		arg.IsAdmin,
		arg.IsActive,
		arg.LastDeactivatedAt,
		arg.NFollowers,
		arg.NFollowing,
		arg.NTweets,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}

const updateAccountByUsername = `-- name: UpdateAccountByUsername :one
UPDATE accounts SET
    email = $2,
    profile_picture_url = $3,
    bio = $4,
    last_login = $5,
    is_admin = $6,
    is_active = $7,
    last_deactivated_at = $8,
    n_followers = $9,
    n_following = $10,
    n_tweets = $11
WHERE username = $1
RETURNING id, username, email, profile_picture_url, bio, last_login, created_at, is_admin, is_active, last_deactivated_at, n_followers, n_following, n_tweets
`

type UpdateAccountByUsernameParams struct {
	Username          string             `json:"username"`
	Email             string             `json:"email"`
	ProfilePictureUrl pgtype.Text        `json:"profile_picture_url"`
	Bio               pgtype.Text        `json:"bio"`
	LastLogin         pgtype.Timestamptz `json:"last_login"`
	IsAdmin           bool               `json:"is_admin"`
	IsActive          bool               `json:"is_active"`
	LastDeactivatedAt pgtype.Timestamptz `json:"last_deactivated_at"`
	NFollowers        pgtype.Int4        `json:"n_followers"`
	NFollowing        pgtype.Int4        `json:"n_following"`
	NTweets           pgtype.Int4        `json:"n_tweets"`
}

func (q *Queries) UpdateAccountByUsername(ctx context.Context, arg UpdateAccountByUsernameParams) (Account, error) {
	row := q.db.QueryRow(ctx, updateAccountByUsername,
		arg.Username,
		arg.Email,
		arg.ProfilePictureUrl,
		arg.Bio,
		arg.LastLogin,
		arg.IsAdmin,
		arg.IsActive,
		arg.LastDeactivatedAt,
		arg.NFollowers,
		arg.NFollowing,
		arg.NTweets,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.ProfilePictureUrl,
		&i.Bio,
		&i.LastLogin,
		&i.CreatedAt,
		&i.IsAdmin,
		&i.IsActive,
		&i.LastDeactivatedAt,
		&i.NFollowers,
		&i.NFollowing,
		&i.NTweets,
	)
	return i, err
}
